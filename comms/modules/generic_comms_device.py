"""
Communication device class
"""

import io
import libscrc
import serial
from .helper import decode_msg


class GenericCommsDevice():
    """
    Base communication device that serializes and deserializes messages
    """

    def __init__(self, port: str, baudrate: int):
        self.current_msg = io.BytesIO()
        self.length = -1
        self.ser = serial.Serial(
            port=port, baudrate=baudrate, bytesize=8, timeout=2, stopbits=serial.STOPBITS_ONE
        )

    @staticmethod
    def __get_crc32(b_in: bytes) -> int:
        """
        """
        return libscrc.crc32(b_in)

    def transmit(self, msg) -> None:
        """
        Expects a TelemMessages object
        """
        # Serialize object without CRC
        buf = io.BytesIO()
        # Accessing LCM autogenerated method
        # pylint: disable=[protected-access]
        msg._encode_one(buf)
        # pylint: enable=[protected-access]

        # Debugging
        print(len(buf.getbuffer().tobytes()))
        print(int.from_bytes(msg.header.length, 'big'))
        # Calculate and write CRC
        crc32 = self.__get_crc32(buf.getbuffer().tobytes())
        buf.write(crc32.to_bytes(4, 'big'))
        # Debugging
        print(len(buf.getbuffer().tobytes()))

        self.ser.write(buf.getbuffer().tobytes())

    def __reset_buffer(self):
        """
        Resets the length and buffer to receive a new message
        """
        self.length = -1
        self.current_msg = io.BytesIO()

    def receive(self):
        """
        Receives a single message and returns a tuple of (bool, TelemMessages object)
        Blocking call until a complete message is received, nonblocking otherwise
        """
        while self.ser.inWaiting():
            read_byte = self.ser.read(1)[0]
            self.current_msg.write(read_byte.to_bytes(1, 'big'))

            if read_byte == 0x7e and self.length == -1:
                # Start of new message
                length_bytes = self.ser.read(size=2)
                self.length = int.from_bytes(length_bytes, 'big')
                print(self.length)
                self.current_msg.write(length_bytes)
            else:
                # Header + Data + CRC
                if len(self.current_msg.getbuffer()) == 4 + self.length + 4:
                    # Check CRC
                    raw_data = self.current_msg.getbuffer().tobytes()
                    calc_crc32 = self.__get_crc32(raw_data[:-4])
                    msg_crc32 = int.from_bytes(raw_data[-4:], 'big')
                    if msg_crc32 == calc_crc32:
                        self.current_msg.seek(0)
                        out = decode_msg(self.current_msg)
                        self.__reset_buffer()
                        return True, out
                    else:
                        self.__reset_buffer()
                        return False, None

        return False, None
